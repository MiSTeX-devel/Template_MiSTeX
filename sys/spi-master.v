/* Generated by Yosys 0.17 (git sha1 6f9602b4c, gcc 11.3.0-1ubuntu1~22.04 -fPIC -Os) */

module sck_divider(clock_enable_in, rst, clk, clock_out);
  reg \$auto$verilog_backend.cc:2083:dump_module$16  = 0;
  wire \$1 ;
  wire \$3 ;
  wire \$5 ;
  wire [2:0] \$7 ;
  wire [2:0] \$8 ;
  input clk;
  wire clk;
  reg [1:0] clock_counter = 2'h0;
  reg [1:0] \clock_counter$next ;
  input clock_enable_in;
  wire clock_enable_in;
  output clock_out;
  reg clock_out = 1'h0;
  reg \clock_out$next ;
  input rst;
  wire rst;
  assign \$1  = clock_counter >= 2'h2;
  assign \$3  = ~ clock_out;
  assign \$5  = clock_counter >= 2'h2;
  assign \$8  = clock_counter + 1'h1;
  always @(posedge clk)
    clock_counter <= \clock_counter$next ;
  always @(posedge clk)
    clock_out <= \clock_out$next ;
  always @* begin
    if (\$auto$verilog_backend.cc:2083:dump_module$16 ) begin end
    \clock_out$next  = clock_out;
    casez (\$1 )
      1'h1:
          (* full_case = 32'd1 *)
          casez (clock_enable_in)
            1'h1:
                \clock_out$next  = \$3 ;
            default:
                \clock_out$next  = 1'h0;
          endcase
    endcase
    casez (rst)
      1'h1:
          \clock_out$next  = 1'h0;
    endcase
  end
  always @* begin
    if (\$auto$verilog_backend.cc:2083:dump_module$16 ) begin end
    (* full_case = 32'd1 *)
    casez (\$5 )
      1'h1:
          \clock_counter$next  = 2'h0;
      default:
          \clock_counter$next  = \$8 [1:0];
    endcase
    casez (rst)
      1'h1:
          \clock_counter$next  = 2'h0;
    endcase
  end
  assign \$7  = \$8 ;
endmodule

module spi_device(spi_device__sdi, spi_device__sck, spi_device__cs, word_in, word_out, word_accepted, word_complete, rst, clk, spi_device__sdo);
  reg \$auto$verilog_backend.cc:2083:dump_module$17  = 0;
  wire \$1 ;
  wire \$11 ;
  wire \$13 ;
  wire [6:0] \$15 ;
  wire \$17 ;
  wire \$19 ;
  wire \$21 ;
  wire \$23 ;
  wire [6:0] \$25 ;
  wire [6:0] \$26 ;
  wire \$28 ;
  wire \$3 ;
  wire \$30 ;
  wire \$32 ;
  wire \$34 ;
  wire \$36 ;
  wire \$38 ;
  wire \$5 ;
  wire \$7 ;
  wire \$9 ;
  (* \amaranth.sample_reg  = 32'd1 *)
  reg \$sample$s$serial_clock$sync$1  = 1'h0;
  wire \$sample$s$serial_clock$sync$1$next ;
  reg [5:0] bit_count = 6'h00;
  reg [5:0] \bit_count$next ;
  input clk;
  wire clk;
  reg [39:0] current_rx = 40'h0000000000;
  reg [39:0] \current_rx$next ;
  reg [39:0] current_tx = 40'h0000000000;
  reg [39:0] \current_tx$next ;
  reg is_first_bit = 1'h0;
  reg \is_first_bit$next ;
  input rst;
  wire rst;
  wire serial_clock;
  input spi_device__cs;
  wire spi_device__cs;
  input spi_device__sck;
  wire spi_device__sck;
  input spi_device__sdi;
  wire spi_device__sdi;
  output spi_device__sdo;
  reg spi_device__sdo = 1'h0;
  reg \spi_device__sdo$next ;
  reg tx_done = 1'h0;
  reg \tx_done$next ;
  output word_accepted;
  reg word_accepted = 1'h0;
  reg \word_accepted$next ;
  output word_complete;
  reg word_complete = 1'h0;
  reg \word_complete$next ;
  output [39:0] word_in;
  reg [39:0] word_in = 40'h0000000000;
  reg [39:0] \word_in$next ;
  input [39:0] word_out;
  wire [39:0] word_out;
  assign \$9  = ~ spi_device__cs;
  assign \$13  = \$sample$s$serial_clock$sync$1  & \$11 ;
  assign \$15  = bit_count + 1'h1;
  assign \$17  = \$15  == 6'h28;
  assign \$1  = ~ spi_device__sck;
  assign \$19  = ~ spi_device__cs;
  assign \$23  = \$sample$s$serial_clock$sync$1  & \$21 ;
  assign \$26  = bit_count + 1'h1;
  assign \$28  = ~ spi_device__cs;
  assign \$32  = \$sample$s$serial_clock$sync$1  & \$30 ;
  assign \$34  = ~ spi_device__cs;
  assign \$38  = \$sample$s$serial_clock$sync$1  & \$36 ;
  assign \$3  = ~ spi_device__cs;
  assign \$5  = ~ \$sample$s$serial_clock$sync$1 ;
  assign \$7  = \$5  & serial_clock;
  always @(posedge clk)
    spi_device__sdo <= \spi_device__sdo$next ;
  always @(posedge clk)
    word_accepted <= \word_accepted$next ;
  always @(posedge clk)
    word_complete <= \word_complete$next ;
  always @(posedge clk)
    word_in <= \word_in$next ;
  always @(posedge clk)
    \$sample$s$serial_clock$sync$1  <= \$1 ;
  always @(posedge clk)
    current_rx <= \current_rx$next ;
  always @(posedge clk)
    is_first_bit <= \is_first_bit$next ;
  always @(posedge clk)
    bit_count <= \bit_count$next ;
  always @(posedge clk)
    tx_done <= \tx_done$next ;
  always @(posedge clk)
    current_tx <= \current_tx$next ;
  always @* begin
    if (\$auto$verilog_backend.cc:2083:dump_module$17 ) begin end
    \word_in$next  = word_in;
    casez (tx_done)
      1'h1:
          \word_in$next  = current_rx;
    endcase
    casez (rst)
      1'h1:
          \word_in$next  = 40'h0000000000;
    endcase
  end
  always @* begin
    if (\$auto$verilog_backend.cc:2083:dump_module$17 ) begin end
    (* full_case = 32'd1 *)
    casez (tx_done)
      1'h1:
          \word_complete$next  = 1'h1;
      default:
          \word_complete$next  = 1'h0;
    endcase
    casez (rst)
      1'h1:
          \word_complete$next  = 1'h0;
    endcase
  end
  always @* begin
    if (\$auto$verilog_backend.cc:2083:dump_module$17 ) begin end
    (* full_case = 32'd1 *)
    casez (tx_done)
      1'h1:
          \word_accepted$next  = 1'h1;
      default:
          \word_accepted$next  = 1'h0;
    endcase
    casez (rst)
      1'h1:
          \word_accepted$next  = 1'h0;
    endcase
  end
  always @* begin
    if (\$auto$verilog_backend.cc:2083:dump_module$17 ) begin end
    \current_tx$next  = current_tx;
    \spi_device__sdo$next  = spi_device__sdo;
    casez (word_accepted)
      1'h1:
          \current_tx$next  = word_out;
    endcase
    (* full_case = 32'd1 *)
    casez (\$3 )
      1'h1:
          casez (\$7 )
            1'h1:
                { \spi_device__sdo$next , \current_tx$next [39:1] } = current_tx;
          endcase
      default:
          \current_tx$next  = word_out;
    endcase
    casez (rst)
      1'h1:
        begin
          \current_tx$next  = 40'h0000000000;
          \spi_device__sdo$next  = 1'h0;
        end
    endcase
  end
  always @* begin
    if (\$auto$verilog_backend.cc:2083:dump_module$17 ) begin end
    \tx_done$next  = 1'h0;
    casez (\$9 )
      1'h1:
          casez (\$13 )
            1'h1:
                casez (\$17 )
                  1'h1:
                      \tx_done$next  = 1'h1;
                endcase
          endcase
    endcase
    casez (rst)
      1'h1:
          \tx_done$next  = 1'h0;
    endcase
  end
  always @* begin
    if (\$auto$verilog_backend.cc:2083:dump_module$17 ) begin end
    \bit_count$next  = bit_count;
    (* full_case = 32'd1 *)
    casez (\$19 )
      1'h1:
          casez (\$23 )
            1'h1:
                \bit_count$next  = \$26 [5:0];
          endcase
      default:
          \bit_count$next  = 6'h00;
    endcase
    casez (rst)
      1'h1:
          \bit_count$next  = 6'h00;
    endcase
  end
  always @* begin
    if (\$auto$verilog_backend.cc:2083:dump_module$17 ) begin end
    \is_first_bit$next  = is_first_bit;
    (* full_case = 32'd1 *)
    casez (\$28 )
      1'h1:
          casez (\$32 )
            1'h1:
                \is_first_bit$next  = 1'h0;
          endcase
      default:
          \is_first_bit$next  = 1'h1;
    endcase
    casez (rst)
      1'h1:
          \is_first_bit$next  = 1'h0;
    endcase
  end
  always @* begin
    if (\$auto$verilog_backend.cc:2083:dump_module$17 ) begin end
    \current_rx$next  = current_rx;
    casez (\$34 )
      1'h1:
          casez (\$38 )
            1'h1:
                \current_rx$next  = { current_rx[38:0], spi_device__sdi };
          endcase
    endcase
    casez (rst)
      1'h1:
          \current_rx$next  = 40'h0000000000;
    endcase
  end
  assign \$25  = \$26 ;
  assign \$sample$s$serial_clock$sync$1$next  = serial_clock;
  assign serial_clock = \$1 ;
  assign \$11  = spi_device__sck;
  assign \$21  = spi_device__sck;
  assign \$30  = spi_device__sck;
  assign \$36  = spi_device__sck;
endmodule

module spi_master(spi_controller__sdo, spi_controller__sck, spi_controller__cs, start_transfer, word_in, word_out, word_complete, clk, rst, spi_controller__sdi);
  reg \$auto$verilog_backend.cc:2083:dump_module$18  = 0;
  wire \$1 ;
  wire \$11 ;
  wire \$2 ;
  wire \$5 ;
  wire \$6 ;
  wire \$9 ;
  (* \amaranth.sample_reg  = 32'd1 *)
  reg \$sample$s$clock_out$sync$1  = 1'h0;
  wire \$sample$s$clock_out$sync$1$next ;
  input clk;
  wire clk;
  wire cs;
  reg [1:0] fsm_state = 2'h1;
  reg [1:0] \fsm_state$next ;
  input rst;
  wire rst;
  wire sck;
  reg sck_divider_clock_enable_in = 1'h0;
  reg \sck_divider_clock_enable_in$next ;
  wire sck_divider_clock_out;
  output spi_controller__cs;
  wire spi_controller__cs;
  output spi_controller__sck;
  wire spi_controller__sck;
  input spi_controller__sdi;
  wire spi_controller__sdi;
  output spi_controller__sdo;
  wire spi_controller__sdo;
  wire spi_device_spi_device__cs;
  wire spi_device_spi_device__sck;
  wire spi_device_spi_device__sdi;
  wire spi_device_spi_device__sdo;
  wire spi_device_word_accepted;
  wire spi_device_word_complete;
  wire [39:0] spi_device_word_in;
  wire [39:0] spi_device_word_out;
  input start_transfer;
  wire start_transfer;
  wire word_accepted;
  output word_complete;
  wire word_complete;
  output [39:0] word_in;
  wire [39:0] word_in;
  input [39:0] word_out;
  wire [39:0] word_out;
  assign \$9  = ~ sck_divider_clock_out;
  assign \$11  = \$sample$s$clock_out$sync$1  & \$9 ;
  assign \$2  = ! fsm_state;
  assign \$1  = \$2  ? sck_divider_clock_out : 1'h1;
  assign \$6  = ! fsm_state;
  assign \$5  = \$6  ? 1'h0 : 1'h1;
  always @(posedge clk)
    \$sample$s$clock_out$sync$1  <= sck_divider_clock_out;
  always @(posedge clk)
    fsm_state <= \fsm_state$next ;
  always @(posedge clk)
    sck_divider_clock_enable_in <= \sck_divider_clock_enable_in$next ;
  sck_divider sck_divider (
    .clk(clk),
    .clock_enable_in(sck_divider_clock_enable_in),
    .clock_out(sck_divider_clock_out),
    .rst(rst)
  );
  spi_device spi_device (
    .clk(clk),
    .rst(rst),
    .spi_device__cs(spi_device_spi_device__cs),
    .spi_device__sck(spi_device_spi_device__sck),
    .spi_device__sdi(spi_device_spi_device__sdi),
    .spi_device__sdo(spi_device_spi_device__sdo),
    .word_accepted(spi_device_word_accepted),
    .word_complete(spi_device_word_complete),
    .word_in(spi_device_word_in),
    .word_out(spi_device_word_out)
  );
  always @* begin
    if (\$auto$verilog_backend.cc:2083:dump_module$18 ) begin end
    \sck_divider_clock_enable_in$next  = sck_divider_clock_enable_in;
    casez (fsm_state)
      2'h1:
        begin
          \sck_divider_clock_enable_in$next  = 1'h0;
          casez (start_transfer)
            1'h1:
                \sck_divider_clock_enable_in$next  = 1'h1;
          endcase
        end
    endcase
    casez (rst)
      1'h1:
          \sck_divider_clock_enable_in$next  = 1'h0;
    endcase
  end
  always @* begin
    if (\$auto$verilog_backend.cc:2083:dump_module$18 ) begin end
    \fsm_state$next  = fsm_state;
    casez (fsm_state)
      2'h1:
          casez (start_transfer)
            1'h1:
                \fsm_state$next  = 2'h2;
          endcase
      2'h2:
          casez (\$11 )
            1'h1:
                \fsm_state$next  = 2'h0;
          endcase
      2'h0:
          casez (spi_device_word_complete)
            1'h1:
                \fsm_state$next  = 2'h1;
          endcase
    endcase
    casez (rst)
      1'h1:
          \fsm_state$next  = 2'h1;
    endcase
  end
  assign \$sample$s$clock_out$sync$1$next  = sck_divider_clock_out;
  assign cs = \$5 ;
  assign sck = \$1 ;
  assign word_complete = spi_device_word_complete;
  assign word_accepted = spi_device_word_accepted;
  assign spi_device_word_out = word_out;
  assign word_in = spi_device_word_in;
  assign spi_device_spi_device__cs = cs;
  assign spi_device_spi_device__sck = sck;
  assign spi_device_spi_device__sdi = spi_controller__sdi;
  assign spi_controller__sdo = spi_device_spi_device__sdo;
  assign spi_controller__cs = cs;
  assign spi_controller__sck = sck;
endmodule
